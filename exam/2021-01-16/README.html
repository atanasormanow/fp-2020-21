<!doctype html>
<html>
<head>
<meta charset="utf-8">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/3.0.1/github-markdown.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.18.1/lib/index.min.js">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markdown-it-texmath@0.6.5/css/texmath.css">
<link rel="stylesheet" href="https://gitcdn.xyz/repo/goessner/mdmath/master/css/vscode-texmath.css">

</head>
<body class="markdown-body">
<p data-line="0" class="code-line"><em>Важно: Решете задачите на Haskell. За всяка от функциите напишете подходящи unit test-ове. За тестовете трябва да се използва HUnit. Решението попълнете в предварително подготвените шаблонни файлове (в GitHub хранилището на курса те са налични в папката <code>templates</code>)</em></p>
<h1 id="d0b7d0b0d0b4d0b0d187d0b0-1-2" data-line="2" class="code-line">Задача 1</h1>
<p data-line="4" class="code-line">Двоично дърво в Haskell ще представяме чрез следния тип, който ви е познат от домашните:</p>
<pre><code data-line="6" class="code-line language-haskell"><div><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Tree</span> a = <span class="hljs-type">EmptyTree</span> | <span class="hljs-type">Node</span> {
                            <span class="hljs-title">value</span> :: <span class="hljs-title">a</span>,
                            <span class="hljs-title">left</span>  :: <span class="hljs-type">Tree</span> <span class="hljs-title">a</span>,
                            <span class="hljs-title">right</span> :: <span class="hljs-type">Tree</span> <span class="hljs-title">a</span>
                          } <span class="hljs-keyword">deriving</span> (<span class="hljs-type">Show</span>,<span class="hljs-type">Read</span>)</span>
</div></code></pre>
<p data-line="14" class="code-line">Например дървото</p>
<pre><code data-line="16" class="code-line"><code><div>    a
   / \
  b   c
 / \   \
d   e   f
 \
  g
</div></code></code></pre>
<p data-line="26" class="code-line">можем да запишем в променлива по следния начин:</p>
<pre><code data-line="28" class="code-line language-haskell"><div><span class="hljs-title">sampleTree</span> = <span class="hljs-type">Node</span> &#x27;a&#x27; (<span class="hljs-type">Node</span> &#x27;b&#x27; (<span class="hljs-type">Node</span> &#x27;d&#x27; <span class="hljs-type">EmptyTree</span>
                                          (<span class="hljs-type">Node</span> &#x27;g&#x27; <span class="hljs-type">EmptyTree</span> <span class="hljs-type">EmptyTree</span>))
                                (<span class="hljs-type">Node</span> &#x27;e&#x27; <span class="hljs-type">EmptyTree</span> <span class="hljs-type">EmptyTree</span>))
                      (<span class="hljs-type">Node</span> &#x27;c&#x27; <span class="hljs-type">EmptyTree</span>
                                (<span class="hljs-type">Node</span> &#x27;f&#x27; <span class="hljs-type">EmptyTree</span> <span class="hljs-type">EmptyTree</span>))
</div></code></pre>
<h2 id="d0b2d0b0d180d0b8d0b0d0bdd182-d0b0-4" data-line="37" class="code-line">Вариант А</h2>
<p data-line="39" class="code-line">Нека е дадено двоично дърво от символи от тип <code>Char</code>. Напишете функция, която връща списък от всички думи, които могат да се образуват по път от корена, до някое от листата на дървото. Ако дървото е празно, да се връща празният списък.</p>
<p data-line="41" class="code-line">Например за дървото от примера списъкът от възможни думи е:</p>
<pre><code data-line="43" class="code-line language-haskell"><div>[<span class="hljs-string">&quot;abdg&quot;</span>, <span class="hljs-string">&quot;abe&quot;</span>, <span class="hljs-string">&quot;acf&quot;</span>]
</div></code></pre>
<p data-line="46" class="code-line">Функцията трябва да има следния тип:</p>
<pre><code data-line="48" class="code-line language-haskell"><div><span class="hljs-title">treeWords</span> :: <span class="hljs-type">Tree</span> <span class="hljs-type">Char</span> -&gt; [<span class="hljs-type">String</span>]
</div></code></pre>
<h2 id="d0b2d0b0d180d0b8d0b0d0bdd182-d0b1-4" data-line="54" class="code-line">Вариант Б</h2>
<p data-line="56" class="code-line">Нека е даден символен низ <code>str</code> и дърво с елементи от тип <code>Char</code>. Напишете функция, която проверява дали <code>str</code> се съдържа в някой път от корена на дървото към негово листо. Символите трябва да се срещат точно в реда им от <code>str</code>. Не е задължително да се срещат непосредствено един след друг.</p>
<p data-line="58" class="code-line">Например в дървото от примера считаме, че</p>
<ul>
<li data-line="60" class="code-line">се съдържат например низовете <code>&quot;&quot;</code>, <code>&quot;a&quot;</code>, <code>&quot;b&quot;</code>, <code>&quot;abdg&quot;</code>, <code>&quot;bd&quot;</code>, <code>&quot;ae&quot;</code>.</li>
<li data-line="61" class="code-line">НЕ СЕ съдържат <code>&quot;ea&quot;</code>, <code>&quot;zx&quot;</code>, <code>&quot;abb&quot;</code></li>
</ul>
<p data-line="63" class="code-line">Функцията трябва да има следния тип:</p>
<pre><code data-line="65" class="code-line language-haskell"><div><span class="hljs-title">treeContains</span>:: <span class="hljs-type">Tree</span> <span class="hljs-type">Char</span> -&gt; <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Bool</span>
</div></code></pre>
<h2 id="d0b2d0b0d180d0b8d0b0d0bdd182-d0b2-4" data-line="70" class="code-line">Вариант В</h2>
<p data-line="72" class="code-line">Нека е дадено двоично дърво от символи от тип <code>Char</code>. <em>&quot;Ниво N&quot;</em> на дървото ще наричаме множество, което дефинираме по следния начин:</p>
<ul>
<li data-line="74" class="code-line">ако дървото е празно, то няма нива;</li>
<li data-line="75" class="code-line">коренът на дървото е единственият елемент в ниво 0;</li>
<li data-line="76" class="code-line">в ниво N влизат всички елементи, които са на разстояние точно N от корена на дървото.</li>
</ul>
<p data-line="78" class="code-line">Например за дървото от примера нивата са:</p>
<ul>
<li data-line="80" class="code-line">ниво 0: { a }</li>
<li data-line="81" class="code-line">ниво 1: { b, c }</li>
<li data-line="82" class="code-line">ниво 2: { d, e, f }</li>
<li data-line="83" class="code-line">ниво 3: { g }</li>
</ul>
<p data-line="85" class="code-line">Напишете функция, която връща списък от всички нива в дървото. Нивата да се представят като думи -- символни низове образувани от елементите в нивото, подредени от най-левия към най-десния. Ако дървото е празно, да се връща празният списък.</p>
<p data-line="87" class="code-line">Например за даденото по-горе дърво, функцията трябва да върне</p>
<pre><code data-line="89" class="code-line language-haskell"><div>[<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;bc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;g&quot;</span>]
</div></code></pre>
<p data-line="93" class="code-line">Функцията трябва да има следния тип:</p>
<pre><code data-line="95" class="code-line language-haskell"><div><span class="hljs-title">treeLevels</span> :: <span class="hljs-type">Tree</span> <span class="hljs-type">Char</span> -&gt; [<span class="hljs-type">String</span>]
</div></code></pre>
<hr>
<h1 id="d0b7d0b0d0b4d0b0d187d0b0-2-2" data-line="102" class="code-line">Задача 2.</h1>
<p data-line="104" class="code-line"><strong>В решението на тази задача не може да се използва рекурсия. Рекурсивни решения ще бъдат оценявани с нула точки.</strong></p>
<p data-line="106" class="code-line"><strong>Упътване:</strong> в задачата използвайте <em>list comprehension</em> и някоя/и от дадените по-долу библиотечни функции на Haskell. За някои от тях (например <code>nub</code> е такава) може да се наложи да импортирате модула <code>Data.List</code>.</p>
<ul>
<li data-line="108" class="code-line"><code>minimum</code> (намира минимален елемент на списък)</li>
<li data-line="109" class="code-line"><code>maximum</code> (намира максимален елемент на списък)</li>
<li data-line="110" class="code-line"><code>nub</code> (премахва повторения от списък)</li>
<li data-line="111" class="code-line"><code>intersect</code> (намира сечение на два списъка)</li>
<li data-line="112" class="code-line"><code>\\</code> (оператор, който намира разлика на два списъка)</li>
<li data-line="113" class="code-line">и т.н.</li>
</ul>
<p data-line="115" class="code-line">Реализирайте функцията</p>
<h2 id="d0b2d0b0d180d0b8d0b0d0bdd182-d0b0-5" data-line="117" class="code-line">Вариант А</h2>
<pre><code data-line="119" class="code-line language-haskell"><div><span class="hljs-title">mapsTo</span> :: <span class="hljs-type">Integral</span> t =&gt; (t -&gt; t) -&gt; t -&gt; t -&gt; (t,t)
<span class="hljs-title">mapsTo</span> f a b
</div></code></pre>
<p data-line="124" class="code-line">Тя получава границите на целочислен интервал <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a,b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">]</span></span></span></span></eq> и функция от вида</p>
<pre><code data-line="126" class="code-line language-haskell"><div><span class="hljs-title">f</span> :: <span class="hljs-type">Integral</span> t =&gt; t -&gt; t
</div></code></pre>
<p data-line="130" class="code-line"><code>mapsTo</code> трябва да върне най-малкия целочислен интервал, който обхваща образа на <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a,b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">]</span></span></span></span></eq> проектиран от <code>f</code>. Казано по-точно, трябва да се върне най-малкият интервал <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[c,d]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span></eq>, такъв, че:</p>
<section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mo stretchy="false">(</mo><mi>x</mi><mo>∈</mo><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∈</mo><mo stretchy="false">[</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall(x \in [a,b])(f(x) \in [c,d]) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∀</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">]</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></eqn></section><p data-line="134" class="code-line">Интервалът да се върне като наредена двойка от неговите граници. Например интервалът <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,5]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mclose">]</span></span></span></span></eq> трябва да се върне като <code>(1,5)</code>.</p>
<h2 id="d0b2d0b0d180d0b8d0b0d0bdd182-d0b1-5" data-line="136" class="code-line">Вариант Б</h2>
<pre><code data-line="138" class="code-line language-haskell"><div><span class="hljs-title">isInjective</span> :: <span class="hljs-type">Integral</span> t =&gt; (t -&gt; t) -&gt; t -&gt; t -&gt; <span class="hljs-type">Bool</span>
<span class="hljs-title">isInjective</span> f a b
</div></code></pre>
<p data-line="143" class="code-line">Тя получава границите на целочислен интервал <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a,b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">]</span></span></span></span></eq> и функция от вида</p>
<pre><code data-line="145" class="code-line language-haskell"><div><span class="hljs-title">f</span> :: <span class="hljs-type">Integral</span> t =&gt; t -&gt; t
</div></code></pre>
<p data-line="149" class="code-line"><code>isInjective</code> връща истина тогава и само тогава, когато рестрикцията на <code>f</code> върху интервала <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a,b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">]</span></span></span></span></eq> е инекция. Тоест, за всички числа в интервала, <code>f</code> връща различни стойности или формално казано:</p>
<section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>∈</mo><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo mathvariant="normal">≠</mo><mi>y</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo mathvariant="normal">≠</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall(x,y \in [a,b])(x \neq y \implies f(x) \neq f(y))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∀</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">]</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7194400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></eqn></section><h2 id="d0b2d0b0d180d0b8d0b0d0bdd182-d0b2-5" data-line="154" class="code-line">Вариант В</h2>
<pre><code data-line="156" class="code-line language-haskell"><div><span class="hljs-title">isSurjective</span> :: <span class="hljs-type">Integral</span> t =&gt; (t -&gt; t) -&gt; t -&gt; t -&gt; t -&gt; t -&gt; <span class="hljs-type">Bool</span>
<span class="hljs-title">isSurjective</span> f a b c d
</div></code></pre>
<p data-line="161" class="code-line">Тя получава целочислени интервали <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a,b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">]</span></span></span></span></eq> и <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[c,d]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span></eq> и функция от вида</p>
<pre><code data-line="163" class="code-line language-haskell"><div><span class="hljs-title">f</span> :: <span class="hljs-type">Integral</span> t =&gt; t -&gt; t
</div></code></pre>
<p data-line="167" class="code-line"><code>isSurjective</code> връща истина тогава и само тогава, когато рестрикцията на <code>f</code> върху <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a,b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">]</span></span></span></span></eq> е сюрекция. Тоест, всеки елемент на интервала <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[c,d]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span></eq> е образ на поне един елемент от <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a,b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">]</span></span></span></span></eq> или формално:</p>
<section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mo stretchy="false">(</mo><mi>y</mi><mo>∈</mo><mo stretchy="false">[</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mi mathvariant="normal">∃</mi><mo stretchy="false">(</mo><mi>x</mi><mo>∈</mo><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>y</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall(y \in [c,d])\exists(x \in [a,b])(y = f(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∀</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mclose">)</span><span class="mord">∃</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">]</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></eqn></section>
</body></html>