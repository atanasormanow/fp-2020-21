# Упражнение 14 - Алгебрични типове данни

[код от упражнението](ex14-20210119-solutions.hs)

### Зад.1.
Да се дефинира тип `BST`, който да представлява двоично наредено дърво, съдържащо стойности от произволен тип във възлите си. Да се дефинират следните функции към него:
- `bstInsert :: Ord a => a -> BST a -> BST a` - добавяне на стойност в дървото
- `bstSearch :: Ord a => a -> BST a -> Bool`  - търсене на стойност в дървото
- `bstValues :: BST a -> [a]`                 - получаване на списък със всички стойности в дървото
- `bstSize :: BST a -> Int`                   - брой стойности, съдържани в дървото
- `bstSort :: Ord a => [a] -> [a]`            - сортиране, използвайки `BST` като междинна структура

### Зад.2*.
Да се дефинира функцията `bstDelete :: Ord a => a -> BST a -> BST a`, която премахва дадена стойност от двоично наредено дърво.

_Упътване:_ използвайте помощна функция, която чрез ротации "избутва" корена на дадено дърво надолу до листо.

### Зад.3.
Да се дефинира тип `Map`, който да представлява структурата от данни асоциативен списък, реализирана с двоично наредено дърво. Да се дефинират следните функции към нея:
- `mapInsert :: Ord k => k -> v -> Map k v -> Map k v` -- вмъкване на ключ със стойност в дървото. Ако стойност за този ключ съществува, нека тя да бъде заместена с новата.
- `mapSearch :: Ord k => k -> Map k v -> Maybe v`      -- търсене на стойност по ключ в дървото (обърнете внимание на върнатия тип)

### Зад.4*.
Да се дефинира тип `Direction`, който да символизира посока при търсене в двоично наредено дърво (ляво или дясно). Да се дефинира функция `bstPath :: Ord a => a -> BST a => ???`, която по даден елемент и двоично наредено дърво намира пътека (последователност от посоки) до елемента в дървото.

_Упътване:_ какъв трябва да е типът на резултата? Нека имаме следното дърво:
```
testBST = BSTNode 2 (BSTNode 1 BSTEmpty BSTEmpty) (BSTNode 3 BSTEmpty BSTEmpty)
```
Какъв резултат се очаква за `bstPath 4 testBST`? Ами за `bstPath 2 testBST`?

### Зад.5.
Да се дефинира тип `Expr`, който да представлява математически израз - функция на един аргумент. Освен този аргумент, този израз може да съдържа само числа (`Double`), или следните операции: събиране, изваждане, умножение, деление или степенуване* на два израза. Да се дефинират следните функции към него:
- `eval :: Expr -> Double -> Double` -- изчислява стойността на функцията по дадена стойност на аргумента ѝ
- `derive :: Expr -> Expr`           -- изчислява производната на дадена функция - тя очевидно също е функция, която искаме да можем отново да диференцираме или оценяваме точно.
- `collapse :: Expr -> Expr`         -- опростява всички поддървета, които съдържат само числа. Помислете как може да се направи оптимално (без излишни обхождания) - вече сме правили нещо такова

\* за улеснение ще позволяваме само повдигане на израз на степен число, или число на степен израз. Това значи, че няма да можем да представяме функции като x<sup>x</sup>, (1+2)<sup>x</sup> или x<sup>(3+5)</sup>

### Зад.6.
Нека имаме следната дефиниция за битвектор - побитово представяне на дадено неотрицателно число:
```
data Bit = Zero | One

data BitVector
  = End
  | BitVector :. Bit

-- Конструкторите могат да са и оператори, т.е. инфиксни, с определени от нас асоциативност и приоритет
infixl 6 :.
```
Дефинирайте функция `toInteger :: BitVector -> Integer`, която прави каквото името ѝ подсказва. Инстанцирайте класовете `Show`, `Eq`, `Ord` и `Num` (може без функцията `negate` поначало):

_Упътване:_ добавете extension-а `{-# LANGUAGE InstanceSigs #-}` в началото на файла, за да си помагаме като пишем сигнатурите на функциите от инстанцираните класове.
```
instance Show BitVector where
  show :: BitVector -> String
  show = undefined

instance Num BitVector where
  fromInteger :: Integer -> BitVector
  fromInteger = undefined
  -- Всичко останало може да се направи с toInteger и fromInteger, но е по-интересно без тях :)
  (+) = undefined
  (*) = undefined
  abs = undefined
  signum = undefined
  negate = undefined

-- Изберете един да реализирате.
-- Другият имплементирайте чрез избрания.
instance Eq BitVector where
  (==) :: BitVector -> BitVector -> Bool
  (==) = undefined
  (/=) :: BitVector -> BitVector -> Bool
  (/=) = undefined

-- Изберете един да реализирате.
-- Другият имплементирайте чрез избрания.
instance Ord BitVector where
  compare :: BitVector -> BitVector -> Ordering
  compare = undefined
  (<=) :: BitVector -> BitVector -> Bool
  (<=) = undefined
```
Можете да дефинирате и други помощни функции като премахване на водещи нули, побитови операции, броене на битове (вдигнати/свалени/общо) и каквото друго се досетите :)