-- sumLast init n - безкраен поток, който започва с init, а всеки следващ елемент е сума на последните n от потока
-- sumLast 3 5 → [3, 3, 6, 12, 24, 48, 93, 183, ... ]
sumLast :: Int -> Int -> [Int]
sumLast initial n =  initial : generate [initial]
  where generate memory = sum memory : generate (sum memory : if length memory >= n then init memory else memory)

-- Да се напише функция transformSum, която преобразува дърво с елементи цели числа в ново дърво със същата структура,
-- в което всеки елемент е заменен със сумата на елементите в поддървото с този корен в началното дърво.
-- '(1 (3 () ()) (4 (5 () ()) 6)) -> '(19 (3 () ()) (15 (5 () ()) 6))


-- Да се генерират всички подсписъци на даден такъв


-- Да се генерира поток sumsOfCubes от тези числа, които са сума от кубовете на две положителни цели числа

-- Път от корен до възел в двоично дърво кодираме с поредица от цифри 0 и 1, която започва с цифрата 1, а за всяка следваща цифра 0 означава завиване по левия клон, а 1 — по десния. Да се реализира функция sameAsCode, която в двоично дърво от числа връща такова число x, което съвпада по стойност с двоичното число, кодиращо пътя от корена до x, или 0, ако такова число няма. Представянето на дървото е по ваш избор.

